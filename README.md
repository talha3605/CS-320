# CS-320

# How can I ensure that my code, program, or software is functional and secure?
Ensuring code is functional and secure can be a daunting task. I have only done tests on code in this course, so far, and that was a bit much in some cases to ensure that everything works. I was not aware of just how involved this was until taking this class. I can ensure my code is secure and functional by sticking to the requirements and by writing extensive tests that provide a high coverage percentage when the code is tested. This was done in my program for this class by testing and testing until my coverage percentages were at least 90%. To make sure the code is functional primarily involved following the requirements and ensuring that it was secure involved writing extensive tests based on requirements. 

# How do I interpret user needs and incorporate them into a program?
I interpret user needs by first reading them and second by breaking them down into aspects that will or will not work with a program. The example that comes to mind is the constraints placed on maximum length and empty submissions. The first one was the names where they could not be null or not longer than 10 characters. I read that and incorporated that into the program by using an if statement which covered both of the failure options. This is a basic way of translating a need into a program because it takes the need directly into a conditional for success. There are more ambiguous requirements sometimes that take some deeper looking. One program I had in another class required the program to be able to, on the push of a button, add time to two separate clocks. That was broken down very extensively into a program but not in this same manner because you had the general requirement but it wasn't something as simple as creating an illegal argument exception.

# How do I approach designing software?
My approach to designing software could use some refinement. I tend to take a look at the requirements documents or interview transcripts if that method is chosen, and create a checklist of requirements. These requirements I then, if applicable, break into a list of objects needed to accomplish this and then do the same for the methods needed. Then, with my various lists in hand, I begin writing the code to meet those requirements. Once the code is working, I then go back over it and make it more efficient wherever I can. It has been a pretty effective method for me so far in my studies, but I could definitely use a more expansive approach and one that is more insightful.
